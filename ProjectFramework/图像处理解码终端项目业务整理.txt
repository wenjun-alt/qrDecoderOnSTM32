****涉及到的几个重要技术解决方案****
{
	1. 硬件上如何将双摄像头与STM32F407的DCMI数字摄像头接口进行连接；
	2. 对摄像头采集到的图像存放在哪里
	3. 如何对双摄像头进行切换控制
	4. 如何对采集到的多二维码图片进行分割操作，分割后的单张二维码图片又存放在哪里
}

内存管理与解码速度
记录1
{
	考虑解码速度，故将图像尺寸 imagewidth定义为
	高度等于宽度且必须是 240 的倍数，
	因为我将 8 位灰度图像申请内存放在 CCM 里
	使得算法运算速度更快一些，且 CCM 只管理 60K 内存（在 malloc.h 中），
	所以最终将输入识别的图像压缩成 240*240=56K 的灰度图像。
	另外的处理方式：
	也可以将内存申请只外部 SRAM 
	这样就可以随意定义 imagewidth 的大小了，只是图像的处理速度会慢一些。
}

硬件参数
{
	LCD
	{
		TFTLCD：4.3寸，分辨率为800*480
		TFTLCD：2.8寸，分辨率为320*240
	}
	
	内存
	{
		内部SRAM：128KB
		{
			SRAM1:112KB
			SRAM2:16KB
		}
		内部CCM：64KB
		外部SRAM：1MB
	}
	
	摄像头OV系列
	{
		低清摄像头：OV2640
		高清摄像头：OV7725
	}
}




业务1（单摄像头方案已完成）
{
	方案框架
	{
		拍照操作（方案变动：改为双摄像头方案采集图片）
		{
			1. 利用STM32F407（M4内核）调用高清摄像头
			拍摄含有多二维码的图片，并将该图片标记为图片1.jpg，
			利用DMA将采集到的图像数据直接传输到内存中，
			至此完成对图像采集存放在SRAM中（即内存）的操作；
			2. 在步骤1操作的同时STM32驱动低清摄像头
			拍摄同一张含有多二维码的图片，
			并将该图片标记为2.jpg，存放在本地SD-Card里；
		}
	}
	
	方案实施知识体系
	{
		硬件
		{
			1. MCU的DCMI接口与OV2640、OV7725在硬件上如何连接
		}
		
		软件
		{
			1. DCMI接口与双摄像头通信；
			2. DMA数据传输；
			{
				DMA采用双缓存机制，接收DCMI的行图像数据
			}
			3. CCM内存管理
			{
				最大可申请240*240的灰度图进行解码
			}
		}
	}
}

业务2
{
	网络通信
	{
		1. 将图片2.jpg传输给服务器（通过神经网络目标检测算法，定位出多个二维码位置信息）；
		2. 接收服务器回传的多个二维码的位置信息；
	}
	 
}

业务3
{
	图片分割操作
	{
		1. 根据服务器回传的二维码的位置信息进行图片分割；
		2. 将图片1.jpg分割为多个二维码的图片（如：图片1_fg1.jpg，图片1_fg2.jpg，图片1_fg3.jpg，图片1_fg4.jpg等），
		并将这些图片进行逐一保存；
	}
}

业务4
{
	解码显示操作
	{
		1. 对业务3分割过后的多个二维码图片进行逐一解码；
		2. 将解码后的信息通过LCD进行显示，同时通过串口打印解码信息。
	}

}